#  1. JavaScript

## 类型

基本类型：string, number, boolean, undefined, null, symbol 

高级类型：object



**Number:**

八进制字面量：第一个数字必须是0，然后是0~7 

十六进制字面量：数值前缀0x，然后是0~9以及A~F(大小写均可)

```js
let octalNum = 070 //八进制的56
let hexNum = 0xA //十六进制的10
```



**Symbol**

Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象

```js
let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor
```



### 类型检测

**typeof** 对于**原始类型**来说，除了 null 会返回`object`，其他都可以显示正确的类型。 对于对象来说，除了函数会返回`function`，其他都会显示 object 。所以说 typeof 并不能准确判断变量到底是什么类型

**instanceof** 是通过原型链来判断，可以判断一个对象的正确类型

```javascript
5 instanceof Number // false
new Number(5) instanceof Number // true
```

**Object.prototype.toString** 「万能方法」

`toString` 是 `Object`的原型方法，而 `Array` ，`function` 等类型作为 `Object`的实例，都重写了 `toString` 方法

```javascript
console.log(Object.prototype.toString.call([]))
// [object Array]
```

**constructor**  对于undefined 和 null，会报错

```javascript
var foo = Symbol("foo")
foo.constructor
// ƒ Symbol() { [native code] }
```



### 原生函数

原生构造函数

```javascript
var a = new String( "abc" );
typeof a; // 是"object"，不是"String"
a instanceof String; // true 
Object.prototype.toString.call( a ); // "[object String]"

// new String("abc") 创建的是字符串 "abc" 的封装对象，而非基本类型值 "abc"

var a = new Boolean( false );
if (!a) {
console.log( "Oops" ); // 执行不到这里
}
// 为 false 创建了一个封装对象，然而该对象是真值（“truthy”）
```



### **类型转换**

![](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/image.png)

在JavaScript中“falsy”的明确列表如下：

- "" （空字符串）
- 0, -0, NaN （非法的number）
- null, undefined
- false

任何不在这个“falsy”列表中的值都是“truthy”

[]、{} 和 function(){} 都不在假值列表中，因此它们都 是真值



### 相等判断

相等和不相等——先转换再比较 （==）
全等和不全等——仅比较而不转换 （===）



**抽象值操作**

- **ToString** 任何一个非 `string` 值被强制转换为一个 `string` 表现形式时，这个转换的过程是由 `ToString` 抽象操作处理的。

  - 内建的基本类型值拥有自然的字符串化形式：`null` 变为 `"null"`，`undefined` 变为 `"undefined"`，`true` 变为 `"true"`。

  - 对普通对象来说，除非自行定义，否则 toString()(Object.prototype.toString())返回 内部属性 [[Class]] 的值，如 "[object Object]"。

- **ToNumber**

  true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0



**隐式强制类型转换**

如果加号两边都是 Number 类型，其规则为：

- 如果 + 号两边存在 NaN，则结果为 NaN（typeof NaN 是 'number'）
- 如果是 Infinity + Infinity，结果是 Infinity
- 如果是 -Infinity + (-Infinity)，结果是 -Infinity
- 如果是 Infinity + (-Infinity)，结果是 NaN

如果加号两边有至少一个是字符串，其规则为：

- 如果 + 号两边都是字符串，则执行字符串拼接
- 如果 + 号两边只有一个值是字符串，则将另外的值转换为字符串，再执行字符串拼接
- 如果 + 号两边有一个是对象，则调用 valueof() 或者 toStrinig() 方法取得值，转换为基本类型再进行字符串拼接。

[] + {}; // "[object Object]"
{} + []; // 0
表面上看 + 运算符根据第一个操作数([] 或 {})的不同会产生不同的结果，实则不然。 

第一行代码中，{} 出现在 + 运算符表达式中，因此它被当作一个值(空对象)来处理。第
4 章讲过 [] 会被强制类型转换为 ""，而 {} 会被强制类型转换为 "[object Object]"。

第二行代码中，{} 被当作一个独立的空代码块(不执行任何操作)。代码块结尾不需要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换(参见第 4 章) 为 0。





## 严格模式

- 变量必须声明后再使用
- 函数的参数不能有同名属性，否则报错
- 不能使用with语句
- 不能对只读属性赋值，否则报错
- 不能使用前缀 0 表示八进制数，否则报错
- 不能删除不可删除的属性，否则报错
- 不能删除变量delete prop，会报错，只能删除属性delete global[prop]
- eval不会在它的外层作用域引入变量
- eval和arguments不能被重新赋值
- arguments不会自动反映函数参数的变化
- 不能使用arguments.callee
- 不能使用arguments.caller
- 禁止this指向全局对象
- 不能使用fn.caller和fn.arguments获取函数调用的堆栈
- 增加了保留字（比如protected、static和interface）



## 作用域

### 词法作用域

JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域，不具有动态作用域。

词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的（this也是）。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。



### this

this，函数执行的上下文，可以通过apply，call，bind改变this的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，nodejs为global），剩下的函数调用，那就是谁调用它，this就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，this就指向哪里。

1. 直接调用指向window 
2. obj.fn()指向最后调用函数的对象 
3. new 指向实例 
4. apply call bind 指向第一个参数

### 闭包

当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包

本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中

由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。



## 原型与继承

每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的**构造函数**的原型对象（**prototype** ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个**原型链**中的最后一个环节。

![](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/GW4Q2a.jpg)

几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。

![](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/Tx0z5g.jpg)

[JavaScript深入之从原型到原型链](https://github.com/mqyqingfeng/Blog/issues/2)

[Javascript继承机制的设计思想](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)



for..in 和 in操作符会查找对象原型链



### new实现

在调用new 的过程中会发生以上四件事情：

1.  首先创建一个空对象，这个对象将会作为执行 new 构造函数() 之后，返回的对象实例
2.  将上面创建的空对象的原型（`__proto__`），指向构造函数的 prototype 属性
3.  将这个空对象赋值给构造函数内部的 this，并执行构造函数逻辑
4.  根据构造函数执行逻辑，返回第一步创建的对象或者构造函数的显式返回值


```
function create() {
    let obj = {}
    let Con = [].shift.call(arguments)
    obj.__proto__ = Con.prototype
    let result = Con.apply(obj, arguments)
    return result instanceof Object ? result : obj
}
```

[JavaScript深入之new的模拟实现](https://github.com/mqyqingfeng/Blog/issues/13)

### **instanceof**实现

```javascript
function myInstanceof(L, R){
    if(typeof L !== 'object'){
        return false
    }
    while(true){
        if(L === null){
            return false
        }
        if(L.__proto__ === R.prototype){
            return true
        }
        L = L.__proto__
    }
}
```



**`Object.create()`**方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。



### 继承 

[重新理解JS的6种继承方式](http://www.ayqy.net/blog/重新理解JS的6种继承方式/)

[JavaScript深入之继承的多种方式和优缺点](https://github.com/mqyqingfeng/Blog/issues/16#)

#### 简单原型链

```javascript
Child.prototype = new Parent()
```

核心：拿**父类实例**来充当子类**原型对象**

问题：

1. 来自原型对象的引用属性是所有实例共享的 
2. 创建子类实例时，无法向父类构造函数传参

#### 借用构造函数

```javascript
function Child (args) {  // ...  
  Parent.call(this, args)
}
```

核心：借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了

问题：

1. 方法都在构造函数中定义，每次创建实例都会创建一遍方法。

2. 只是实现了实例属性继承，Parent 原型的方法在 Child 实例中并不可用。

#### 组合继承

```javascript
function Child (args1, args2) {
    // ...
    this.args2 = args2
    Parent.call(this, args1) //核心
 }
 Child.prototype = new Parent() //核心
 Child.prototype.constrcutor = Child
```

问题：

1.Child 实例会存在 Parent 的实例属性。因为在 Child 构造函数中执行了 Parent 构造函数。同时，`Child.__proto__` 也会存在同样的 Parent 的实例属性，且所有 Child 实例的 `__proto__` 指向同一内存地址。

#### 寄生组合式继承

组合继承最大的缺点是会调用两次父构造函数。

一次是设置子类型实例的原型的时候：

```
Child.prototype = new Parent();
```

一次在创建子类型实例的时候：

```
var child1 = new Child('kevin', '18');
```

回想下 new 的模拟实现，其实在这句中，我们会执行：

```
Parent.call(this, name);
```

在这里，我们又会调用了一次 Parent 构造函数。

那么我们该如何精益求精，避免这一次重复调用呢？

如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？

```javascript
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {
    Parent.call(this, name);//核心
    this.age = age;
}

function beget(o) { //原型式继承 也是Object.create的模拟实现
    function F() {} //切掉了原型对象上多余的那份父类实例属性
    F.prototype = o;
    return new F();
}

Child.prototype = beget(Parent.prototype); // 核心
// 等同于 Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;    // 核心
```



**上述实现也都没有对静态属性的继承**

另一个比较完整的实现为：

```javascript
function inherit(Child, Parent) {
    // 继承原型上的属性
   Child.prototype = Object.create(Parent.prototype)
    // 修复 constructor
   Child.prototype.constructor = Child
   // 存储超类
   Child.super = Parent
   // 静态属性继承
   if (Object.setPrototypeOf) {
       // setPrototypeOf es6
       Object.setPrototypeOf(Child, Parent)
   } else if (Child.__proto__) {
       // __proto__ es6 引入，但是部分浏览器早已支持
       Child.__proto__ = Parent
   } else {
       // 兼容 IE10 等陈旧浏览器
       // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法
       for (var k in Parent) {
           if (Parent.hasOwnProperty(k) && !(k in Child)) {
               Child[k] = Parent[k]
           }
       }
   }

}
```

上面静态属性继承存在一个问题：在陈旧浏览器中，属性和方法的继承我们是静态拷贝的，继承完后续父类的改动不会自动同步到子类。这是不同于正常面向对象思想的。但是这种组合式继承，已经相对完美、优雅。

#### ES6继承

ES5 的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面（`Parent.apply(this)`）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。

[class-extends|阮一峰](http://es6.ruanyifeng.com/#docs/class-extends)

ES6 与 ES5 中的继承有 2 个区别，第一个是，ES6 中子类会继承父类的属性，第二个区别是，super() 与 A.call(this) 是不同的，在继承原生构造函数的情况下，体现得很明显，ES6 中的子类实例可以继承原生构造函数实例的内部属性，而在 ES5 中做不到。

[ES6 与 ES5 继承的区别](https://juejin.im/post/5d615b7f6fb9a06b0202ccb5)

[ES5/ES6 的继承除了写法以外还有什么区别？](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20#)

### 继承判断

`Object.getPrototypeOf`方法可以用来从子类上获取父类。

```javascript
Object.getPrototypeOf(ColorPoint) === Point
// true
```



## 事件循环

[JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)

### 浏览器

![image-20191223192614099](http://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/2019-12-23-112614.png)

事件循环的主要工作就是一轮一轮地检查macrotask queue，并处理这些任务

**宏任务**：简称task，包含执行整体的js代码，事件回调，XHR回调，定时器（setTimeout/setInterval/setImmediate），requestAnimationFrame，IO操作，UI render

**微任务**：也称job，更新应用程序状态的任务，包括promise回调，MutationObserver，process.nextTick，Object.observe(已废弃)



1. 事件循环是js实现异步的核心

2. 每轮事件循环分为3个步骤：

   > a) 执行macrotask队列的**一个**任务
   > b) 执行完当前microtask队列的**所有**任务
   > c) UI render

3. 浏览器只保证requestAnimationFrame的回调在重绘之前执行，没有确定的时间，何时重绘由浏览器决定

   

[深入理解js事件循环机制（浏览器篇）](http://lynnelv.github.io/js-event-loop-browser)

[彻底搞懂浏览器Event-loop](https://github.com/YvetteLau/Blog/issues/4)

### node

Node 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运⾏。每当进⼊某⼀个阶段的时候，都会从
对应的回调队列中取出函数去执⾏。当队列为空或者执⾏的回调函数数量到达系统设定的阈值，就会进⼊下⼀阶段。

![Node.jsç«¯](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/n4DwJQ.png)

- **timers 阶段**：这个阶段执行timer（`setTimeout`、`setInterval`）的回调
- I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调
- idle, prepare 阶段：仅node内部使用
- **poll 阶段**：获取新的I/O事件, 适当的条件下node将阻塞在这里
- **check 阶段**：执行 `setImmediate()` 的回调
- close callbacks 阶段：执行 `socket` 的 `close` 事件回调

重点看`timers`、`poll`、`check`3个阶段

[深入理解js事件循环机制（Node.js篇）](http://lynnelv.github.io/js-event-loop-nodejs)



## 内存管理

基本数据类型保存在栈内存当中，引用类型保存在堆内存当中

![图片](http://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/2019-12-21-093052.jpg)

### **垃圾回收**

[通过垃圾回收机制理解 JavaScript 内存管理](https://juejin.im/post/5c4409fbf265da616f703d5a)

- **引用计数**

一个对象在没有其他的引用指向它的时候就被认为“可被回收的”。 循环引用会有问题

- **标记清除**

1. 垃圾回收器生成一个根列表。根通常是将引用保存在代码中的全局变量。在JavaScript中，window对象是一个可以作为根的全局变量。

2. 所有的根都被检查和标记成活跃的（不是垃圾），所有的子变量也被递归检查。所有可能从根元素到达的都不被认为是垃圾。

3. 所有没有被标记成活跃的内存都被认为是垃圾。垃圾回收器就可以释放内存并且把内存还给操作系统。

![img](http://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/2019-12-21-094004.gif)



## xhr

[你不知道的 XMLHttpRequest](https://juejin.im/post/58e4a174ac502e006c1e18f4)

```js
function myAsyncFunction(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.onload = () => resolve(xhr.responseText);
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
};
```

XmlHttpRequest 对象在不同浏览器中不同的创建方法，以下是跨浏览器的通用方法：

```js
// Provide the XMLHttpRequest class for IE 5.x-6.x:
// Other browsers (including IE 7.x-8.x) ignore this
//   when XMLHttpRequest is predefined
var xmlHttp;
if (typeof XMLHttpRequest != "undefined") {
    xmlHttp = new XMLHttpRequest();
} else if (window.ActiveXObject) {
    var aVersions = ["Msxml2.XMLHttp.5.0", "Msxml2.XMLHttp.4.0", 
        "Msxml2.XMLHttp.3.0", "Msxml2.XMLHttp", "Microsoft.XMLHttp"];
    for (var i = 0; i < aVersions.length; i++) {
        try {
            xmlHttp = new ActiveXObject(aVersions[i]);
            break;
        } catch (e) {}
    } else {
        throw new Error("No XHR object available")
    }
}
```



## 跨域

### 同源策略

同源策略（Same Origin Policy）是一种约定，是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。

同源，是指「协议、域名、端口」都相同

非同源的情况下，以下行为会受到限制：

- 对 Cookie、LocalStorage 和 IndexDB 的读取
- 对 DOM 和 JS 对象的读取
- Ajax 请求的正常执行

A网页是`http://w1.example.com/a.html`，B网页是`http://w2.example.com/b.html`，那么只要设置`document.domain = 'example.com';`，两个网页就可以共享Cookie。



### jsonp

![JSONP](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/Ot9Bn5.jpg)



1.利用 `<script>` 标签允许跨域访问的特点。

2.需要服务器对返回的 JSON 进行包裹。

先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好一个同名回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数。

[JSONP 简介](https://lotabout.me/2016/JSONP/)

### cors

[CORS 简单请求+预检请求](https://github.com/amandakelake/blog/issues/62)

[HTTP访问控制（CORS）|MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)

**简单请求**

不会触发CORS预检的请求称为简单请求，满足以下**所有条件**的才会被视为简单请求，基本上我们日常开发只会关注**前面两点**

1. 使用`GET、POST、HEAD`其中一种方法
2. 只使用了如下的安全首部字段
   - `Accept`
   - `Accept-Language`
   - `Content-Language`
   - `Content-Type`仅限以下三种
     - `text/plain`
     - `multipart/form-data`
     - `application/x-www-form-urlencoded`
   - HTML头部header field字段：`DPR、Download、Save-Data、Viewport-Width、WIdth`
3. 请求中的任意`XMLHttpRequestUpload` 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问
4. 请求中没有使用 ReadableStream 对象

对于简单请求，浏览器直接发出CORS请求。浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个`Origin`字段。

`Origin`字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

- Access-Control-Allow-Origin

  该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

- Access-Control-Allow-Credentials

  可选。表示是否允许发送Cookie。

- Access-Control-Expose-Headers

  可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。

**预检请求**

**非简单请求**的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight），以获知服务器是否允许该实际请求。"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。这种请求使用OPTIONS方法，发送下列头部

- Origin：与简单请求相同
- Access-Control-Request-Method：请求自身使用的方法
- Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。

收到这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送以下头部与浏览器进行沟通：

- Access-Control-Allow-Origin:与简单请求相同
- Access-Control-Allow-Methods：允许的方法，多个方法逗号分隔
- Access-Control-Allow-Headers：允许的头部，多个头部逗号分隔
- Access-Control-Max-Age：应该将这个Preflight请求缓存多长时间（s为单位），在此期间，不用发出另一条预检请求
- Access-Control-Allow-Credentials：可选。表示是否允许发送Cookie

如果浏览器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获

一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

**带凭证的请求**

如果发起请求时设置`withCredentials` 标志设置为 `true`，从而向服务器发送cookie。如果服务器端接受带凭证的请求，会在相应头部中携带`Access-Control-Allow-Credentials: true`

否则，浏览器将不会把响应内容返回给请求的发送者

对于附带身份凭证的请求，服务器不得设置 `Access-Control-Allow-Origin` 的值为`*`， 必须是某个具体的域名

注意，简单 GET 请求不会被预检；如果对此类带有身份凭证请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页

**完整请求流程**

![dd16afcc-c37b-4269-a427-4e42c6e5773f](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/50205881-c409b080-03a4-11e9-8a57-a2a6d0e1d879.png)





## 事件机制

### 事件流

事件流分为两种，捕获事件流和冒泡事件流。
捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点。
冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点。

DOM事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段。

**事件委托**的实现是利用事件冒泡的机制



**DOM0事件处理程序**

```js
var btn = document.getElementById('btn')
btn.onclick = function(){
	// ... 
}
// 会在事件流的冒泡阶段被处理
```



**DOM2事件处理程序**

```js
btn.addEventListener("click", function(){
	// ...
}, false)
// 最后这个布尔值参数为false（默认）表示在冒泡阶段调用；为true，表示在捕获阶段调用
```





## DOM基础

```js
var element=document.createElement("p");    
document.body.appendChild(element);     //添加到body 子节点下
element.innerHTML="我也想去看看";       //给元素加上内容

var p=document.getElementById("attr");      //获取段落节点
document.body.removeChild(p);
```



## Promise

**状态**

- "has-resolution" - Fulfilled

  resolve(成功)时。此时会调用 `onFulfilled`

- "has-rejection" - Rejected

  reject(失败)时。此时会调用 `onRejected`

- "unresolved" - Pending

  既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等

![promise-resolve-flow](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/LM8Tvh.png)

**方法**

[`Promise.all(iterable)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)

[`Promise.race(iterable)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)

[`Promise.reject(reason)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject)

[`Promise.resolve(value)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)



### **Promise原型**

**属性**

- `Promise.prototype.constructor`

  返回被创建的实例函数.  默认为 [`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise) 函数.

**方法**

- [`Promise.prototype.catch(onRejected)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch)

  添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果.

- [`Promise.prototype.then(onFulfilled, onRejected)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)

  添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve.

- [`Promise.prototype.finally(onFinally)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally)

  添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象。回调会在当前promise运行完毕后被调用，无论当前promise的状态是完成(fulfilled)还是失败(rejected)



## ES6

### generator

### symbol

### proxy

### 箭头函数与普通函数的区别

1. 箭头函数中this指向定义时外层函数中this，且不可更改
2. 没有prototype
3. 没有arguments，可以使用rest参数获取（...args）







## 模块化

namespae模式

- 减少 Global 上的变量数目

- 本质是对象，一点都不安全

匿名闭包 ：*IIFE* 模式

- 模块外部无法修改没有暴露出来的变量、函数

### CommonJS

commonJs 服务端模块规范

```javascript
//utils.js
module.exports = {
    test,
}
//test.js
const {test} = require('utils')
```

commonjs同步性不适于浏览器
故出现异步加载模块规范

### AMD 和 CMD

**AMD**

Asynchromous Module Defination异步模块定义。

实现是requireJS

```javascript
define(['./a','./b'],function(a, b){
    a.do();
    //...
})

require(['myModule'], function (my){
　 my.printName();
});
```

require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。



**CMD**

Common Module Definition，通用模块定义

实现是seaJs

```javascript
define(function(require, exports, module){
    const a = require('a');
    a.do();
    //...
})

seajs.use(['myModule.js'], function(my){

});
```

**区别**

- amd 提前执行 cmd延迟执行
- amd 推崇依赖提前 cmd 推崇依赖就近
- amd api默认是一个多用 cmd 单一职责



### ESM



**CommonJS和ESM区别**

- CommonJS ⽀持动态导⼊，也就是 require(${path}/xx.js) ，后者⽬前不⽀持，但是已有提案
- CommonJS 是同步导⼊，因为⽤于服务端，⽂件都在本地，同步导⼊即使卡住主线程影响也不⼤。⽽后者是异步导⼊，因为⽤于浏览器，需要下载⽂件，如果也采⽤同步导⼊会对渲染有很⼤影响
- CommonJS 在导出时都是值拷⻉，就算导出的值变了，导⼊的值也不会改变，所以如果想更新值，必须重新导⼊⼀次。但是 ES Module 采⽤引用绑定的⽅式，导⼊导出的值都指向同⼀个内存地址，所以导⼊值会跟随导出值变化
- ES Module 会编译成 require/exports 来执⾏的



## 浏览器存储

### cookie、sessionStorage、localStorage区别

|      名称      |                            生命期                            | 大小限制 |                         与服务器通信                         |
| :------------: | :----------------------------------------------------------: | :------: | :----------------------------------------------------------: |
|     cookie     | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 |   4KB    | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 |
|  localStorage  |                   除非被清除，否则永久保存                   |   5MB    |               仅在浏览器中保存，不与服务器通信               |
| sessionStorage |         仅在当前会话下有效，关闭页面或浏览器后被清除         |   5MB    |               仅在浏览器中保存，不与服务器通信               |



# 2. HTML+CSS

## 行内元素块级元素

|          | 行内元素                                         | 块级元素                                                     |
| -------- | ------------------------------------------------ | ------------------------------------------------------------ |
|          | 一个行内元素只占据它对应标签的边框所包含的空间。 | 块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”   |
| 内容     | 行内元素只能包含数据和其他行内元素。             | 可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。 |
| 常见标签 | a,span,br,img,button,input,label,select,b        | div,h1,p,form,ol,ul,pre,table,hr                             |

## 盒模型

![img](http://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/2019-12-17-141503.png)

**标准盒模型**

盒模型宽高 = 内容的宽高 + 内边距padding + 边框border + 外边距margin

**怪异盒模型**

元素盒模型宽高 = 内容的宽高（元素的宽高 + padding + border） + 外边距margin

在低版本 IE 里，若不添加 <!DOCTYPE html> 的文档声明，就会按照 IE 盒模型进行解析

**box-sizing**

box-sizing: border-box; 可以让元素按照 IE 盒模型进行解析

box-sizing: content-box;默认值，标准和模型解析

## position

relative fixed absolute区别

| 取值     | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| absolute | 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。 |
| fixed    | 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。 |
| relative | 生成相对定位的元素，相对于其正常位置进行定位。因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。 |
| static   | 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 |

## display



## 两栏布局

1.BFC

2.float + margin-left

![](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/uT5KR3.png)

3.absolute + margin-left

![image-20200112223405933](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/8t5p23.png)

4.absolute + left

![image-20200112223556899](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/ylD9qI.png)



## flex布局

采用 Flex 布局的元素，称为 `Flex 容器`（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 `Flex 项目`（flex item），简称“项目”。



![flex.jpeg](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/lzDP2i.png)



**父元素属性**

| 属性名          |                        属性值                         |                             备注                             |
| --------------- | :---------------------------------------------------: | :----------------------------------------------------------: |
| display         |                         flex                          |     定义了一个flex容器，它的直接子元素会接受这个flex环境     |
| flex-direction  |         row,row-reverse,column,column-reverse         |                        决定主轴的方向                        |
| flex-wrap       |               nowrap,wrap,wrap-reverse                |                 如果一条轴线排不下，如何换行                 |
| flex-flow       |            [flex-direction] , [flex-wrap]             | 是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap` |
| justify-content | flex-start,flex-end,center,space-between,space-around |     设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式     |
| align-items     |      flex-start,flex-end,center,baseline,stretch      |     设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式     |

**子元素属性**

| 属性名      |                      属性值                      |                             备注                             |
| ----------- | :----------------------------------------------: | :----------------------------------------------------------: |
| order       |                      [int]                       | 默认情况下flex order会按照书写顺训呈现，可以通过order属性改变，数值小的在前面，还可以是负数。 |
| flex-grow   |                     [number]                     | 设置或检索弹性盒的扩展比率,根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间 |
| flex-shrink |                     [number]                     | 设置或检索弹性盒的收缩比率,根据弹性盒子元素所设置的收缩因子作为比率来收缩空间 |
| flex-basis  |                  [length], auto                  |                  设置或检索弹性盒伸缩基准值                  |
| align-self  | auto,flex-start,flex-end,center,baseline,stretch | 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式，可以覆盖父容器align-items的设置 |



## 居中

[css居中](https://segmentfault.com/a/1190000006129638)

### 水平居中

**行内元素**在块级元素中

```css
.center-children {
    text-align: center;
}
```

**块级元素**

 单个块级元素

```
.center-me {
    margin: 0 auto;
}
```

多个块级元素同行居中，可以使用`inline-block的text-align `或者`flexbox`来实现居中

```css
// flexbox
.center-parent {
    display: flex;
    justify-content: center;
}
```

多个块级元素同列居中，利用`单个块级元素`的`居中`方法来实现

### 垂直居中

**行内元素**

单行行内元素可以利用`padding`或者`line-height`来实现

```css
.text {
    padding-top: 30px;
    padding-bottom: 30px;
}
// or
.text {
    height: 100px;
    line-height: 100px;
}
```

多行行内元素可以使用`flexbox`

```css
.center-flexbox {
    display: flex;
    flex-direction: column;
    justify-content: center;
}
// or
.center-flexbox {
    display: flex;
    align-items: center;
}
```

```css
.wrapper {
  display: table;
  .box {
    display: table-cell;
    vertical-align: middle;
  }
}
```



**块级元素**

参考垂直水平居中



### 垂直水平居中

- 宽度和高度知道(利用`垂直居中`的`块级元素`高度知道)

  ```
  .parent {
    position: relative;
  }
  
  .child {
    width: 200px;
    height: 100px;
  
    position: absolute;
    top: 50%;
    left: 50%;
  
    margin: -50px 0 0 -100px;
  }
  ```


- 宽度和高度不知道(利用`垂直居中`的`块级元素`高度不知道)

  ```
  .parent {
    position: relative;
  }
  .child {
    position: absolute;
    top: 50%; //相对于包含块
    left: 50%;
    transform: translate(-50%, -50%); //相对于自身
  }
  ```

- flexbox

  ```
  .parent {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  ```



## BFC

BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于定位方案的普通流。

**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。**通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。

只要元素满足下面任一条件即可触发 BFC 特性：

- body 根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)

**BFC 特性及应用**

1. 同一个 BFC 下外边距会发生折叠，**想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。**
2. BFC 可以包含浮动的元素，解决浮动元素高度坍塌 （清除浮动）
3. BFC 可以阻止元素被浮动元素覆盖(两栏自适应布局)

![image-20200112223000982](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/SMJfZr.png)![](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/HyvEhV.png)

[10 分钟理解 BFC 原理](https://zhuanlan.zhihu.com/p/25321647)





## 清除浮动

**1. 设置父元素的高度**

不灵活，只适用于子元素高度已知的情况

**2. 自带属性 clear**

```css
.clearfix::after {
    display: block;
    clear: both;
    content: "";
}
```

该方法在元素内部清除兄弟元素浮动影响是比较推崇的

**3. 利用BFC**
根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算。因此清除浮动，只需要触发一个BFC即可

该方法是需要把属性添加到父元素当中，以解决内部元素浮动影响。不能用于解决兄弟元素的浮动问题。



## 屏幕适配布局

### REM

rem官方定义『The font size of the root element』，即根元素的字体大小。rem是一个相对的CSS单位，1rem等于html元素上font-size的大小

```js
(function () {
    var html = document.documentElement;
    function onWindowResize() {
        html.style.fontSize = html.getBoundingClientRect().width / 20 + 'px';
    }
    window.addEventListener('resize', onWindowResize);
    onWindowResize();
})();

```

https://www.jianshu.com/p/fde40f0c20cb#

### 响应式原理

一个网站兼容多个终端 通过媒体查询检测不同设备的屏幕尺寸 页面头部必须有meta申明的viewport

## 语义化
```html
<article>
<section>
<nav>
<aside>
<header>
<footer>
...
```



## DOCTYPE

告诉浏览器使用哪个html规范
不存在会使用混杂模式
标准模式：浏览器支持最高标准
混杂模式：比较宽松向后兼容



## CSS面试题

1.flex:1的含义

2.css实现扇形、三角形





# 3. 网络

## 分层

**1.因特网协议栈（五层）**

**应用层**：应用层协议分布在多个端系统上，一个端系统应用程序与另外一个端系统应用程序交换信息分组，信息分组为`报文(message)`。HTTP（web文档的请求和传送）、SMTP（电子邮件报文的传输）、FTP（两个端系统之间文件传送）、DNS（域名解析）

**运输层**：向两台主机进程之间的通信提供通用的数据传输服务。在应用程序端点之间传送应用层报文，信息分组为`报文段(segment)`

- TCP：**面向连接**的服务，**可靠**确保传递和流量控制（发送方/接收方速率匹配），将长报文划分为短报文，并提供拥塞控制机制，当网络拥塞时，源抑制其传输速率

- UDP：无连接服务，没有可靠性，没有流量控制，没有拥塞控制

**网络层**：将网络层信息分组`数据报(datagram)`从一台主机移动到另一台主机。IP协议，定义了在数据报中的各个字段以及端系统和路由器如何作用域这些字段

**链路层**：网络层通过源和目的地之间的一系列路由器路由数据报。为了将分组从一个结点（主机或路由器）移动到路径上的下一个结点，网络层必须依靠链路层的服务。特别是在每个结点。网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个结点。在下个结点，链路层将数据报上传给网络层。链路层分组`帧(frame)`

**物理层**：链路层将帧从一个网络元素移动到邻近的网络元素，物理层的任务是将帧中的一个一个`比特`从一个结点移动到下一个结点。

**TCP/IP协议模型（四层）**

![img](http://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/2019-12-17-141828.png)

**2.OSI**(Open System Interconnection，开放系统互连)**模型（七层）**

![img](http://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/2019-12-17-141821.png)



## HTTP

**超文本（Hypertext）、传输（Transfer）、协议（Protocol）**

### http请求组成

![img](http://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/2019-12-17-141835.png)

### http2.0和http1.1和http1.0的区别

[HTTP1.0，HTTP1.1，HTTP2.0升级的变化和区别](http://www.kaonao.net/detail/132.html)

[HTTP 2 的新特性你 get 了吗？](https://link.zhihu.com/?target=https%3A//www.qcloud.com/community/article/541321%3FfromSource%3Dgwzcw.93399.93399.93399)

[5分钟快速理解 HTTP2](https://mp.weixin.qq.com/s/fb02vTE884Txx6npW2mfcQ)

[HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS](https://zhuanlan.zhihu.com/p/43787334)

[HTTP/2 简介](https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn)

**http1.0 => 1.1**

- HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。

- HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准。HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略带宽优化及网络连接的使用

- 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除

- 另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。通过Content-Length字段来判断当前请求的数据是否已经全部接收。不允许同时存在两个并行的响应。

**http1.1 => 2.0**

相比 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化：

- **二进制分帧：**HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。 **HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。**每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。

- **头部压缩：**HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。
  - HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；
  - 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
  - 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。

- **多路复用：**所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。优先级高的流会被优先发送。图片请求的优先级要低于 CSS 和 SCRIPT，这个设计可以确保重要的东西可以被优先加载完。

- **Server Push：**服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。



### http缓存

![图片](http://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/2019-12-22-130105.png)

[浏览器缓存知识小结及应用](https://www.cnblogs.com/lyzg/p/5125934.html)

[缓存谁都懂，一问都哑口](https://www.zhihu.com/market/paid_column/1167078439772721152/section/1169989450636640256)

[缓存（二）——浏览器缓存机制：强缓存、协商缓存](https://github.com/amandakelake/blog/issues/41#)



缓存流程：

- 浏览器在加载资源时，根据请求头的`expires`和`cache-control`判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。
- 如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过`last-modified`和`etag`验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源
- 如果前面两者都没有命中，直接从服务器加载资源

协商缓存需要配合强缓存使用，因为如果不启用强缓存的话，协商缓存根本没有意义。



**Expires**

http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。
Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效

```http
Expires: Wed, 11 May 2018 07:20:00 GMT
```

**Cache-Control**

Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些

```http
Cache-Control: max-age=315360000
```



作为请求首部时，cache-directive 的可选值有：
![img](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/cViEaI.png)

作为响应首部时，cache-directive 的可选值有：
![img](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/UPjW1f.png)

[Cache-Control取值](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)



**Last-Modified，If-Modified-Since**

`Last-Modified` 表示本地文件最后修改日期，浏览器会在request header加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag ???

 Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；也要考虑到，一些文件也许会周期性的更改，但是他的内容并不改变，仅仅改变的修改时间。为了弥补这种小缺陷，就有了 【ETag、If-None-Match】这一对 header 头来进行协商缓存的判断。

**ETag、If-None-Match**

`Etag`就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的。`If-None-Match`的header会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来

同时 Etag 也有自己的问题：相同的资源，在两台服务器产生的 Etag 是不是相同的，所以对于使用服务器集群来处理请求的网站来说， Etag 的匹配概率会大幅降低。所在在这种情况下，使用 Etag 来处理缓存，反而会有更大的开销。



**优先级**：Cache-Control > Expires > ETag > Last-Modified

强制缓存优先级最高，并且资源的改动在缓存有效期内浏览器都不会发送请求，因此强制缓存的使用适用于大型且不易修改的的资源文件，例如第三方 CSS、JS 文件或图片资源。如果更加灵活的话，我们也可以为文件名加上 hash进行版本的区分。

协商缓存灵活性高，适用于数据的缓存。采用 Etag 标识进行对比灵活度最高，也最为可靠。对于数据的缓存，我们可以重点考虑存入内存中，因为内存加载速最快，并且数据体积小。

Cache-control 的 max-age 和 Expires 同时出现，那么 max-age 的优先级更高，他会默认覆盖掉 expires

Etag 优先级比 Last-Modified 高，如果他们组合出现在请求头当中，我们会优先采用 Etag 策略。

![](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/TaPBHp.jpg)



### http cookies

[http cookies | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)

### get post区别

[GET 和 POST 到底有什么区别？](https://www.zhihu.com/question/28586791/answer/767316172)

幂等、缓存

### https

[一个故事讲完https](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)

https://juejin.im/post/5e11ff54e51d4541013f12ba

### 常见状态码

**1XX临时回应** 表示客户端请继续

**2XX 成功**

200 OK，表示从客户端发来的请求在服务器端被正确处理

204 No content，表示请求成功，但响应报文不含实体的主体部分

205 Reset Content，表示请求成功，但响应报⽂不含实体的主体部分，但是与 204 响应不同在于

要求请求方重置内容

206 Partial Content，进行范围请求

**3XX 表示请求的目标有变化** 希望客户端进一步处理

301 moved permanently，永久性重定向，表示资源已被分配了新的 URL

302 found，临时性重定向，表示资源临时被分配了新的 URL

303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源

304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况

307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

> 303和307是HTTP1.1新加的服务器响应文档的状态码，它们是对HTTP1.0中的302状态码的细化，主要用在对非GET、HEAD方法的响应上。文档规定：浏览器对303状态码的处理跟原来浏览器对HTTP1.0的302状态码的处理方法一样；浏览器对307状态码处理则跟原来HTTP1.0文档里对302的描述一样。 303和307的存在，归根结底是由于POST方法的非幂等属性引起的。
>
> 303状态码：对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI。
>
> 307状态码：对于POST请求，表示请求还没有被处理，客户端应该向Location里的URI重新发起POST请求。



**4XX 客户端错误**

400 bad request，请求报⽂存在语法错误

401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息

403 forbidden，表示对请求资源的访问被服务器拒绝

404 not found，表示在服务器上没有找到请求的资源

405  Method Not Allowed  客户端请求中的方法被禁止

413  Request Entity Too Large  由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息

415   不支持媒体类型  请求的格式不受请求页面的支持

**5XX 服务器器错误**

500 internal sever error，表示服务器端在执⾏请求时发⽣了错误

501 Not Implemented，表示服务器不支持当前请求所需要的某个功能

502  Bad Gateway  充当网关或代理的服务器，从远端服务器接收到了一个无效的请求      

503 service unavailable，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求

## DNS

域名系统（Domain Name System，DNS）是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库

- 先过浏览器搜索自己的 DNS 缓存（可以使用 chrome://net-internals/#dns 来进行查看）

- 上一步未找到对应缓存的 IP 地址时，搜索操作系统中的 DNS 缓存

- 上一步未找到对应缓存的 IP 地址时，操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求，为什么说这是迭代的 DNS 解析请求呢？

  这个过程

  - LDNS 向 Root Name Server（根域名服务器，如 com、net、org 等解析顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器地址
  - LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址
  - LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址 LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来

- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来

DNS 解析整个过程，分为：递归查询过程和迭代查询过程。

DNS 使用无连接的 UDP 协议来进行查询，这样的方式降低了开销，也使得速度更快，保证了高效的通信，但是没有太考虑安全问题。它使用目的端口为 53 的 UDP 明文进行通信，这也带来了诸如 DNS 欺骗、DNS Cache 污染、DNS 放大攻击等问题，一些「黑心」运营商就可以利用这一点达到一些别用用心的目的。



## CDN

CDN的全称是`Content Delivery Network`，即`内容分发网络`，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户`就近`获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有`内容存储`和`分发技术`。



## TCP和UDP

**TCP：**

- 面向连接的服务：在应用层报文开始流动之前，TCP让客户和服务器相互交换运输层控制信息这个握手过程提示客户和服务器，使他们为大量分组的到来做好准备。在握手阶段后，一个TCP连接在两个进程的套接字之间建立。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。当应用程序结束报文发送时，必须拆除该连接。
- 可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，他能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。
- 具有拥塞控制机制：当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程。

**UDP：**

- 不提供不必要服务的轻量级运输协议，仅提供最小服务。
- 是无连接的，因此两个进程通信前没有握手过程。
- UDP协议提供一种不可靠数据传送服务。
- 没有包括拥塞控制机制，所以UDP的发送端可以用它选定的任何速率向其下层（网络层）注入数据



**TCP为什么可靠**

- 数据包校验：如果接收端校验出包有错，则进行丢弃且不进行相应。
- 对失序数据包重排序：TCP 协议会对失序数据包进行排序，然后再交给应用层。
- 丢弃重复数据。
- 应答机制：当接收端接收到数据之后，将发送确认信息。
- 超时重发：当发送端发出数据后，它启动一个定时器，如果超出计时器的时限，将重发这个报文段。
- 流量控制：前面提到过，TCP 连接的每一方都有固定大小的缓冲空间，可防止接收端缓冲区溢出，这就是流量控制。TCP 使用可变大小的滑动窗口协议来进行流量控制。

通过滑动[窗口实现](https://www.bilibili.com/video/av52231781?from=search&seid=4390756521381960633)



### 三次握手

1. 客户端随机生成一个 sequence number，并发送 SYN 报文到服务端，请求连接
2. 服务端发送 SYN＋ACK，在应答请求的同时，也随机生成一个 sequence id，请求同步
3. 客户端应答，服务端收到应答后双方建立连接。

正如 SYN 标志的含义，三次握手的过程在建立连接的过程中完成了自身初始 sequence number 的同步。使用随机生成的 sequence number 是为了防止在网络中滞后的报文影响新建立的连接。

三次握手的重要问题是：为什么要三次？因为信道不可靠。考虑两次握手。假设客户端发送的第一个 SYN 在网络中滞留了，客户端因此重发 SYN 并建立连接，使用直到释放。此时滞留的第一个 SYN 终于到了，根据两次握手的规则，服务端直接进入 ESTABLISHED 状态，而此时客户端根本没有连接，不会理会服务端发送的报文，白白浪费了服务端的资源。

事实上，只要信道不可靠，双方永远都没有办法确认对方知道自己将要进入连接状态。例如三次握手，最后一次 ACK 如果丢失，则只有客户端进入连接状态。四次、五次、多少次握手都有类似问题，三次其实是理论和实际的一个权衡。

![image-20191217194034577](http://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/2019-12-17-140339.png)

### 四次挥手

1. 发起方发送 FIN 报文，代表断开连接
2. 接收方响应 ACK 报文，并在自己发送完未处理的报文后发送 FIN 报文
3. 发起方接收 ACK 报文后等待接收方的 FIN 报文，收到后发送 ACK 报文，自己进入 TIME_WAIT 状态，等待 2MSL 后关闭连接
4. 接收方收到 ACK 报文，关闭连接



![img](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/4-way-handshake.svg)

为什么需要 4 次挥手？一般会说因为连接是双方的，每一方关闭连接时需要 FIN+ACK。因此一共 4 次。而从上图来看，主要是因为接收方发送 ACK 和发送 FIN 之间可能有间隔，接收方需要等待应用程序处理结束后发送 FIN 报文。如果 ACK+FIN 一起发送，则就变成三次挥手了。

在做短连接做压测的时候经常会出现大量端口处理 TIME_WAIT 状态，导致无端口可用。为什么需要这个状态？

1. 防止滞后的报文被后续建立的连接接收，因此结束连接前先等待 2MSL 的时间。（MSL 是最大的报文存活时间，一来一回可以认为与上次连接相关的报文都不在网络中了）

   MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃

2. 确保接收方已经正确关闭连接，考虑发起方最后一次 ACK 滞留，则接收方一直处于 LAST_ACK 状态，而不会关闭连接。那么此时发送方重新建立连接 SYN，则由于序列号不同，处于 LAST_ACK 的接收方会响应 RST 报文。即连接未正确关闭导致后续连接无法建立。

[TCP连接的建立与释放(三次握手四次挥手)](https://www.bilibili.com/video/av69145968)



## REST和RPC

**REST**



**RPC**（remote procedure call）是指远程过程调用，比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的接口，由于不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。

[RPC太太太太太太太容易理解啦](http://blog.itpub.net/69900354/viewspace-2564401)

http://www.kaonao.net/detail/133.html

[微服务调用为啥用RPC框架，http不更简单吗？](https://zhuanlan.zhihu.com/p/61364466)






# 4. React

## 基础知识

### 生命周期

[react-lifecycle-methods-diagram](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

**React16.3.0之前生命周期**

> 创建期:

1. constructor(props, context)
2. componentWillMount()
3. render()
4. componentDidMount()

> 运行时:

1. componentWillReceiveProps(nextProps, nextContext) （props发生变化时触发）
2. shouldComponentUpdate(nextProps, nextState, nextContext)
3. componentWillUpdate(nextProps, nextState, nextContext)
4. render
5. componentDidUpdate(prevProps, prevState, snapshot)

> 卸载时

componentWillUnmount()

**React16.3.0之后的生命周期**

> 创建期:

1. constructor(props, context)
2. static getDerivedStateFromProps(props, status)
3. render()
4. componentDidMount()

> 运行时

1. static getDerivedStateFromProps(props, status)
2. shouldComponentUpdate(nextProps, nextState, nextContext)
3. render
4. getSnapshotBeforeUpdate(prevProps, prevState)
5. componentDidUpdate(prevProps, prevState, snapshot)



### 受控组件、非受控组件

**controlled_Component ( 受控组件 )**

将表单状态保存在React组件中（state），呈现表单的React组件也会控制用户输入后所发生的情况。表单元素数据托管到React组件中的这种方式叫做 `受控组件`

对于受控组件来说，每个 state 突变都有一个相关的事件处理函数。

**uncontrolled_Component ( 非受控组件 )**

与受控组件相反，表单数据由dom元素自身管理的组件叫 `非受控组件`

React不能控制

[controlled-vs-uncontrolled-inputs-react](https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/)

[受控组件和非受控组件](https://ymbo.github.io/2018/02/07/受控组件和非受控组件/)

[受控组件和非受控组件](https://riptutorial.com/zh-CN/reactjs/example/9777/不受控制的组件)

[深入 React 技术栈 表单](https://www.zhihu.com/pub/reader/119565131/chapter/975185378386440192)



### 高阶组件

```tsx
const wrapAuth = <P extends object>(ComposedComponent: React.ComponentType<P>) => class AuthComponent extends React.Component<P & Props, State> {
    readonly state: State = {
        authorized: false
    };

    render() {
        let { authorized } = this.state;
        let { authKey, hideDenied, ...props } = this.props;
        if (authorized === true) {
            return <ComposedComponent { ...props as P} />;
        } else if (hideDenied) {
            return null;
        }
    }
};
        
function iiHOC(WrappedComponent) {
  return class Enhancer extends WrappedComponent {
    render() {
      return super.render()
    }
  }
}
```

### Render props



## react16

### **fiber**

V16以前react渲染问题：

1.渲染是同步的，会造成阻塞

2.没有优先级

fiber：异步渲染。让用户感知的性能提升，例如输入和动画

![](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/HOkXBj.jpg)

Phase1: render phase 会在时间分片结束时被打断，进行的工作会被放弃。所以可能会多次执行。render phase的生命周期函数里不能有副作用。

Phase2: commit phase 不会被打断



### 错误边界

如果一个 class 组件中定义了 [`static getDerivedStateFromError()`](https://react.docschina.org/docs/react-component.html#static-getderivedstatefromerror) 或 [`componentDidCatch()`](https://react.docschina.org/docs/react-component.html#componentdidcatch) 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 `static getDerivedStateFromError()` 渲染备用 UI ，使用 `componentDidCatch()` 打印错误信息。

**区别**

componentDidCatch：commit phase发送错误时调用，ssr不能用

static getDerivedStateFromError：render phase发生错误时调用，ssr能用



### suspense

**解决的问题**

1.代码分片

2.异步获取数据

**使用**

```jsx
// Clock.js
import React from "react";
import moment from "moment";
const Clock = () => <h1>{moment().format("MMMM Do YYYY, h:mm:ss a")}</h1>;
export default Clock;

// Usage of Clock
const Clock = React.lazy(() => {
    console.log("start importing Clock");
    return import("./Clock");
});

<Suspense>
    {show ? <Clock /> : null}
</Suspense>

<Suspense fallback={<div>Loading...</div>}>
    {show ? <Clock /> : null}
</Suspense>
```

```jsx
import { unstable_createResource as createResource } from 'react-cache';
const resource = createResource(functionReturnAPromise);
const Foo = () => {
    const result = resource.read();
    return (
        <div>{result}</div>
    );
};

<Suspense>
    <Foo />
</Suspense>
```

**原理**

```js
getDerivedStateFromError(error) {
    if (isPromise(error)) {
        error.then(reRender);
    }
}
```

[深度理解 React Suspense](https://juejin.im/post/5c7d4a785188251b921f4e26)



### hooks

**背景**

react认为class难理解，生命周期函数难理解 => 函数式组件

函数式组件无法完全取代类组件 => hooks模拟生命周期等 class组件特性

**hooks api**

useState

useEffect

```javascript
useEffect(()  =>  {
  // Async Action
}, [dependencies])
```

`useEffect()`接受两个参数。第一个参数是一个函数，异步操作的代码放在里面，该函数可以返回一个函数（**将在组件卸载时运行**）；。第二个参数是一个数组，用于给出 Effect 的依赖项，对应的状态发生变化，`useEffect()`就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行`useEffect()`。

useContext

useMemo

useCallback

**优势**



**原理**

根据调用次序cache记录useState

**demo**

```jsx
function Timer({num}){
    const [count, setCount] = useState(num)
    useEffect(()=> {
        const timer = setInterval(()=> setCount(count => count - 1), 1000)
        return ()=> {
            clearInterval(timer)
        }
    }, [])
    return <h1>{count}</h1>
}
```



## 原理解析

React的render函数返回的是一个DOM描述，结果仅仅是轻量级的js对象，reactjs在调用setState的时候会更新DOM，而且是先更新virtual dom，然后和实际dom比较，最后更新dom。React厉害的地方不是说他比真实的dom速度快，而是你不敢数据怎么变化，我都以最小的代价来更新视图。方法就是我在内存当中使用新的数据来构建一个virtual dom，然后和旧DOM进行比较，找出差异，然后更新到DOM节点上。当我们修改dom上的一个节点对应的state，react会立即将他标记为“脏状态”，在事件循环的最后才重新渲染所有的脏节点。在实际的代码中，会对新旧两棵树进行一次深度优先遍历，这样每一个节点都会有一个唯一的标记，每遍历到一个节点，就把该节点和新的树进行比较，如果有差异就记录到一个对象中，最后把差异应用到真正的DOM树上。算法实现步骤为：用js对象模拟DOM树，比较两颗虚拟DOM的差异，把差异应用到真正的DOM树上，DOM DIFF采用的是增量更新的方式，类似于打补丁。React需要为节点添加key来保证算法的效率。Key属性可以帮助react定位到正确的节点进行比较。从而大幅度减少DOM操作，提高性能。

### 虚拟dom

1. 用js对象结构表示dom树的结构，构建dom树
2. 当状态变更时，重新构造新的对象树，然后新旧对比差异
3. 将差异应用到1构建的dom树上

### diff算法

[React 源码剖析系列 － 不可思议的 react diff](https://zhuanlan.zhihu.com/p/20346379)

>标准的diff算法复杂度为O(n^3),无法满足性能要求

![](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/InjW0K.jpg)



Key 应该具有稳定，可预测，以及列表内唯一的特质

当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改导致无法预期的变动。

[这是](https://codepen.io/pyuyu/pen/KKwGodZ?editors=0011) 展示使用下标作为 key 时导致的问题，重新排列，排序，以及在列表头插入会有问题。

[小前端读源码 - React（浅析Keys原理）](https://zhuanlan.zhihu.com/p/65321621)

[关于 React key 在同层级节点下的作用解析](https://zhuanlan.zhihu.com/p/94198683)

### setState

[深入 setState 机制](https://github.com/sisterAn/blog/issues/26#)

[setState：这个API设计到底怎么样](https://zhuanlan.zhihu.com/p/25954470)

### 事件机制

- React 中的事件机制并不是原生的那一套，事件没有绑定在原生 DOM 上 ，大多数事件绑定在 document 上（除了少数不会冒泡到 document 的事件，如 video 等)
- 同时，触发的事件也是对原生事件的包装，并不是原生 event
- 出于性能因素考虑，合成事件（syntheticEvent）是被池化的。这意味着合成事件对象将会被重用，在调用事件回调之后所有属性将会被废弃。这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。





### react router

[单页面应用路由实现原理：以 React-Router 为例](https://github.com/youngwind/blog/issues/109#)

[前端路由实现与 react-router 源码分析](https://github.com/joeyguo/blog/issues/2#)

[深入理解 react-router 路由系统](https://zhuanlan.zhihu.com/p/20381597)



## 状态管理

### flux

![img](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/5aNrSU.jpg)

![img](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/zo61UP.jpg)

更严格的数据流控制，禁止 View 和 Model 之间的直接对话。



一个 Flux 应用包含四个部分：

- Dispatcher ，处理动作分发，维持 Store 之间的依赖关系；

- Store，负责存储数据和处理数据相关逻辑；

- Action，驱动 Dispatcher 的 JavaScript 对象；

- View，视图部分，负责显示用户界面。

[demo ](https://github.com/mocheng/react-and-redux/tree/master/chapter-03/flux)

Flux应用中的数据以单一方向流动：

1. 视图产生动作消息，将动作传递给调度器。
2. 调度器将动作消息发送给每一个数据中心。
3. 数据中心再将数据传递给视图。

单一方向数据流还具有以下特点：

- 集中化管理数据。常规应用可能会在视图层的任何地方或回调进行数据状态的修改与存储，而在Flux架构中，所有数据都只放在Store中进行储存与管理。
- 可预测性。在双向绑定或响应式编程中，当一个对象改变时，可能会导致另一个对象发生改变，这样会触发多次级联更新。对于Flux架构来讲，一次Action触发，只能引起一次数据流循环，这使得数据更加可预测。
- 方便追踪变化。所有引起数据变化的原因都可由Action进行描述，而Action只是一个纯对象，因此十分易于序列化或查看。

**不足**

**1.Store 之间依赖关系**：在 Flux 的体系中，如果两个 Store 之间有逻辑依赖关系，就必须用上 Dispatcher 的 waitFor 函数，该函数传入一个被依赖store 在register 函数的返回值 dispatch-Token。

**2.难以进行服务器端渲染**：在 Flux 的体系中，有一个全局的 Dispatcher ，然后每一个 Store 都是一个全局唯一的对象。和一个浏览器网页只服务于一个用户不同，在服务器端要同时接受很多用户的请求，如果每个 Store 都是全局唯一的对象，那不同请求的状态肯定就乱套了。并不是说 Flux 不能做服务器端渲染，只是说让 Flux 做服务器端渲染很困难

**3.Store 混杂了逻辑和状态**：Store 封装了数据和处理数据的逻辑，用面向对象的思维来看，这是一件好事，毕竟对象就是这样定义的。但是，当我们需要动态替换一个 Store 的逻辑时，只能把这个 Store 整体替换掉，那也就无法保持 Store 中存储的状态。



#### alt

在alt中，alt的Action事实上包含了以上的两个方面：

- **flux意义上的Action**: 作为一个View和Store之间的命令和数据传递的载体
- **flux意义上的Dispatcher**: 封装了Dispatcher的功能

所以通过alt框架来编写项目的时候:

- 我们根本不需要处理如何调用Dispatcher
- 我们也不需要编写Dispatcher，因为alt的Store本身就包含了Dispatcher的功能



### redux

![](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/20200113230228.png)

Flux 的基本原则是“单向数据流”，Redux 在此基础上强调三个基本原则：

·唯一数据源（ Single Source of Truth ）；应用的状态数据应该只存储在唯一的一个 Store 上

·保持状态只读（ State is read-only ）；

·数据改变只能通过纯函数完成（ Changes are made with pure functions ）。

**1.唯一数据源**

Flux 中，应用可以拥有多个 Store，往往根据功能把应用的状态数据划分给若干个 Store 分别存储管理

**2.保持状态只读**

保持状态只读，就是说不能去直接修改状态，要修改 Store 的状态，必须要通过派发一个 action 对象完成，这一点，和 Flux 的要求并没有什么区别。

**3.数据改变只能通过纯函数完成**

Redux 中没有 Dispatcher 的概念，这里所说的纯函数就是 Reducer`(previousState, action) => newState`。(Redux 这个名字的前三个字母 Red 代表的就是 Reducer，Redux 名字的含义是 Reducer+Flux)。

它根据应用的状态和当前的 action 推导出新的 state。Redux 中有多个 reducer，每个 reducer 负责维护应用整体 state 树中的某一部分，多个 reducer 可以通过 `combineReducers` 方法合成一个根reducer，这个根reducer负责维护完整的 state，当一个 action 被发出，store 会调用 dispatch 方法向某个特定的 reducer 传递该 action，reducer 收到 action 之后执行对应的更新逻辑然后返回一个新的 state，state 的更新最终会传递到根reducer处，返回一个全新的完整的 state，然后传递给 view。



**Redux 和 Flux 之间最大的区别**就是对 store/reducer 的抽象，Flux 中 store 是各自为战的，每个 store 只对对应的 controller-view 负责，每次更新都只通知对应的 controller-view；而 Redux 中各子 reducer 都是由根reducer统一管理的，每个子reducer的变化都要经过根reducer的整合。

![dw topic](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/14de9d4b.png)

[Redux从设计到源码](https://tech.meituan.com/2017/07/14/redux-design-code.html)

[完全理解 redux（从零实现一个 redux）](https://github.com/brickspert/blog/issues/22#)



### mobx

![](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/20200113231109.png)



mobx也不断暴露出了它的缺点，就是数据流太随意，出了bug之后不好追溯数据的流向，这个缺点正好体现出了redux的优点所在，所以针对于小项目来说，社区推荐使用mobx，对大项目推荐使用redux

[MobX](http://www.ayqy.net/blog/mobx/)



# 5. 前端工程化

关注的是**性能、稳定性、可用性、可维护性**

模块化、组件化、规范化、自动化

## 性能优化

### 网页性能

- 减少请求
  1. 不请求（缓存）
  2. 合并请求
  3. 减少重定向
  4. 按需加载（懒加载）
  5. 资源唯一性（图片复用）
- 加快请求
  1. 减少dns查找
  2. 优化请求头
  3. gzip body
  4. 压缩内容（minify）
  5. 图片优化（格式）
  6. 并行加载（资源不同域 cdn）
- 渲染更快
  1. 加载顺序
  2. 避免表达式跟滤镜
  3. GPU加速（css3）
  4. 避免回流与重绘

## webpack

### Tree  shaking

Tree-shaking的本质是消除无用的js代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为DCE（dead code elimination）。

Dead Code 一般具有以下几个特征

•代码不会被执行，不可到达

•代码执行的结果不会被用到

•代码只会影响死变量（只写不读）

ESM特点：

- 只能作为模块顶层的语句出现
- import 的模块名只能是字符串常量
- import binding 是 immutable的

ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。



# 6.设计模式与架构

## mv*模式

### MVC

即Model View Controller，简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示。



![mvc.png](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/a4AmMu.jpg)



- View 接受用户交互请求
- View 将请求转交给Controller处理
- Controller 操作Model进行数据更新保存
- 数据更新保存之后，Model会通知View更新
- View 更新变化数据使用户得到反馈

### MVVM

即Model-View-ViewModel，将其中的 View 的状态和行为抽象化，让我们可以将UI和业务逻辑分开。MVVM的优点是低耦合、可重用性、独立开发。



![mvvm.jpg](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/uPic/xcCqxm.jpg)



- View 接收用户交互请求
- View 将请求转交给ViewModel
- ViewModel 操作Model数据更新
- Model 更新完数据，通知ViewModel数据发生变化
- ViewModel 更新View数据

MVVM模式和MVC有些类似，但有以下不同

- ViewModel 替换了 Controller，在UI层之下
- ViewModel 向 View 暴露它所需要的数据和指令对象
- ViewModel 接收来自 Model 的数据



MVVM就是在前端页面上，应用了扩展的MVC模式，我们关心Model的变化，MVVM框架自动把Model的变化映射到DOM结构上，这样，用户看到的页面内容就会随着Model的变化而更新

[MVC、MVP 和 MVVM 对比笔记](https://segmentfault.com/a/1190000018675102)

[MVC，MVP 和 MVVM 的图示](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)



## 设计模式





# 7.web安全

## xss

[前端安全系列（一）：如何防止XSS攻击？](https://tech.meituan.com/2018/09/27/fe-security.html)

[前端Hack之XSS攻击个人学习笔记](https://www.0x002.com/2019/前端Hack之XSS攻击个人学习笔记/#P3P)

Cross-Site Scripting（跨站脚本攻击），为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

#### 存储型 XSS

存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

#### 反射型 XSS

反射型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

#### DOM 型 XSS

DOM 型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

**危害**

- **窃取网页浏览中的cookie值**

  通过script脚本获得当前页面的cookie值，通常会用到document.cookie

- **劫持流量实现恶意跳转**

  ```js
  <script>window.location.href="http://www.baidu.com";</script>
  ```

  那么所访问的网站就会被跳转到百度的首页。

**防御**

- 首先是过滤。对诸如<script>、<img>、<a>等标签进行过滤。

- 其次是编码。像一些常见的符号，如<>在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。

- 输入长度限制

  

## csrf

[前端安全系列（二）：如何防止CSRF攻击？](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

[CSRF 攻击的应对之道](https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html)

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

一个典型的CSRF攻击有着如下的流程：

- 受害者登录a.com，并保留了登录凭证（Cookie）。
- 攻击者引诱受害者访问了b.com。
- b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。
- a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- a.com以受害者的名义执行了act=xx。
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。

**防御措施**

- 验证 HTTP Referer 字段和 Origin
- 请求添加 token 并验证：在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中
- Set-Cookie响应头新增Samesite属性：它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax
  - Strict模式：表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie
  - Lax模式：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie



# 8.浏览器与V8

### 从输入URL到看到页面全过程

[当你在浏览器中输入 google.com 并且按下回车之后发生了什么](https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst#g)

[从浏览器输入一个 url 到页面渲染，涉及的知识点及优化点](https://github.com/sunyongjian/blog/issues/34#)

浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；

把请求回来的 HTML 代码经过解析，构建成 DOM 树；

计算 DOM 树上的 CSS 属性；

最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；

一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；

合成之后，再绘制到界面上。



### 代码执行

v8引擎执行js
词法分析 -> 语法分析 -> 预编译 -> 解释执行

### AST

https://zhuanlan.zhihu.com/p/27289600

https://github.com/frontend9/fe9-library/issues/154

机器并不能直接理解JS语言，所以这里就需要一个中介帮忙程序解释并且将其编译成机器指令码给计算机执行。这个过程就叫**编译**。

而我们chrome浏览器里的V8引擎就是帮我们做这个事情的中介。

编译一般分为三个步骤：

- **词法分析(laxical Analysis)** 词法分析的意思就是，将代码块切分成最小的单位。这些最小单位称为token。 比如 var a = 2;可以切分成var,a,=,2。
- **语法分析(Syntatic Analysis)** 将词法单元转换成一个有层级，代表程序语法结构的树，这就是我们经常说的AST，抽象语法树。

注意：词法分析跟语法分析不是完全独立的，而是交错运行的。也就是说，并不是等所有的token都生成之后，才用语法分析器来处理。一般都是每取得一个token，就开始用语法分析器来处理了。

- **代码生成(Code Genaration)**

最后一步就是将AST转成计算机可以识别的机器指令码。

V8引擎的编译过程基本就是上面这个过程，但是它多了一步生成字节码的过程。 首先用解析器生成AST，然后用解释器Ignition根据语法树生成字节码，最后再用TurboFan将字节码生成机器指令码。

为什么要先转成字节码？是因为直接生成机器指令码太占内存了。



### 渲染流程

构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node

构建渲染树（construct）：解析对应的CSS样式文件信息

布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；

绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点。

![img](https://static001.geekbang.org/resource/image/63/4c/6391573a276c47a9a50ae0cbd2c5844c.jpg)

css在加载过程中不会影响到DOM树的生成，但是会影响到Render树的生成，进而影响到layout，所以一般来说，style的link标签需要尽量放在head里面，因为在解析DOM树的时候是自上而下的，而css样式又是通过异步加载的，这样的话，解析DOM树下的body节点和加载css样式能尽可能的并行，加快Render树的生成的速度。

js脚本应该放在底部，原因在于js线程与GUI渲染线程是互斥的关系，如果js放在首部，当下载执行js的时候，会影响渲染行程绘制页面，js的作用主要是处理交互，而交互必须得先让页面呈现才能进行，所以为了保证用户体验，尽量让页面先绘制出来。

### 重绘和回流

[你真的了解回流和重绘吗](https://segmentfault.com/a/1190000017329980)





# 9.Node

### node实现高并发

### node服务健康检查 容灾处理



# 10.数据库

left join 和 right join 有什么区别

数据库索引



# 11.CS基础

### 进程与线程

进程是系统进行资源分配和调度的基本单位

线程是系统进行运算调度的最小单位

区别：进程是线程的容器，不同进程有独立的内存空间，不同线程共享所在进程的资源。

进程 = 线程 + 内存 + 文件/网络句柄



[进程与线程的一个简单解释](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

进程（process）=火车，线程(thread)=车厢

- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”



# 12.TypeScript

### type和interface

区别：

type 可以声明基本类型别名，联合类型，元组等类型

interface 能够声明合并



# 13.正则

[正则表达式30分钟入门教程](https://www.jb51.net/tools/zhengze.html)

### 规则

**元字符**

| 代码 | 说明                         |
| ---- | ---------------------------- |
| .    | 匹配除换行符以外的任意字符   |
| \w   | 匹配字母或数字或下划线或汉字 |
| \s   | 匹配任意的空白符             |
| \d   | 匹配数字                     |
| \b   | 匹配单词的开始或结束         |
| ^    | 匹配字符串的开始             |
| $    | 匹配字符串的结束             |

**反义**

| 代码/语法 | 说明                                       |
| --------- | ------------------------------------------ |
| \W        | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S        | 匹配任意不是空白符的字符                   |
| \D        | 匹配任意非数字的字符                       |
| \B        | 匹配不是单词开头或结束的位置               |
| [^x]      | 匹配除了x以外的任意字符                    |
| [^aeiou]  | 匹配除了aeiou这几个字母以外的任意字符      |

**重复**

| 代码/语法 | 说明             |
| --------- | ---------------- |
| *         | 重复零次或更多次 |
| +         | 重复一次或更多次 |
| ?         | 重复零次或一次   |
| {n}       | 重复n次          |
| {n,}      | 重复n次或更多次  |
| {n,m}     | 重复n到m次       |

**后向引用**

| 分类         | 代码/语法                                                    | 说明                               |
| ------------ | ------------------------------------------------------------ | ---------------------------------- |
| 捕获         | (exp)                                                        | 匹配exp,并捕获文本到自动命名的组里 |
| (?<name>exp) | 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) |                                    |
| (?:exp)      | 匹配exp,不捕获匹配的文本，也不给此分组分配组号               |                                    |
| 零宽断言     | (?=exp)                                                      | 匹配exp前面的位置                  |
| (?<=exp)     | 匹配exp后面的位置                                            |                                    |
| (?!exp)      | 匹配后面跟的不是exp的位置                                    |                                    |
| (?<!exp)     | 匹配前面不是exp的位置                                        |                                    |

### 常见正则问题

url：`/((ht|f)tps?):\/\/([\w-]+(\.[\w-]+)*\/)*[\w-]+(\.[\w-]+)*\/?(\?([\w\-.,@?^=%&:/~+#]*)+)?/`

email：` /^[A-Za-z0-9]+([_\.][A-Za-z0-9]+)*@([A-Za-z0-9\-]+\.)+[A-Za-z]{2,6}$/`

`'12000000234145675.11'.replace(/(\d)(?=(\d{3})+\.)/g, function($1){return $1 + ','})`







# 14.算法

### 排序

![](https://pyuyu-1253816789.cos.ap-beijing.myqcloud.com/20200114225429.png)

[十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)

**插入排序**：小规模数据或者基本有序时高效

**希尔排序**：插入排序的优化版

把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高

**快排**

优化

第K大值

### 链表

链表是否有环 空间复杂度要求为1

实现单向链表

### 二叉树

遍历

二叉树是否有和为n的路径

二叉树求最大高度



# 15.手写代码

**防抖节流**

**发布订阅（观察者模式）**

**call、apply、bind**

**数组扁平**

**柯里化**

柯里化的基本方法和函数绑定时一样的：使用也给闭包返回一个函数。两者的区别时，当函数被调用时，返回的函数还需要设置一些传入的参数。

```js
// 第一版
var curry = function (fn) {
    var args = [].slice.call(arguments, 1);
    return function() {
        var newArgs = args.concat([].slice.call(arguments));
        return fn.apply(this, newArgs);
    };
};

function add(a, b) {
    return a + b;
}

//或者
var addCurry = curry(add, 1);
addCurry(2) // 3
```



**深拷贝**

**手写promise**

**promise.all**

```javascript
function A(name, color) {
    this.name = name
    this.color = color
}
A.prototype.say = () => {
    return `hello i am ${this.name} , color is ${this.color}`
}

let C = A.bind(null, 'cat')
let cat = new C('blue')
Boolean(cat.say() === `hello i am cat , color is blue` && cat instanceof C && cat instanceof A)

//使这个布尔值为真，实现那个bind方法
```


# 资料整理

